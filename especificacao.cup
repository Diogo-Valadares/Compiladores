/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    public void syntax_error(java_cup.runtime.Symbol currToken) {
        System.out.println("Erro de sintaxe na linha: "+(currToken.left+1)+" caracter: " +(currToken.right+1));
    }
    // Connect this parser to a scanner!
    //scanner s;
    //Parser(scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
//scan with {: return s.next_token(); :};

/* terminais. */
terminal            COMMA, SEMICOLON, SQUARE_BRACKET_OPEN, SQUARE_BRACKET_CLOSE, PARENTHESES_OPEN, PARENTHESES_CLOSE, CURLY_BRACKET_OPEN, CURLY_BRACKET_CLOSE;
terminal            ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, GREATER_THAN, LESS_THAN;
terminal            EQ, EQEQ, AND, OR, XOR, NOT;
terminal            INTEGER_KEYWORD, BOOLEAN_KEYWORD, CHARACTER_KEYWORD, FLOAT_KEYWORD;
terminal            IF, ELSE, WHILE, FOR, PRINT, SCAN;
terminal            FLOAT, BOOLEAN, INTEGER, CHAR;
terminal            IDENTIFIER;
terminal            CONTINUE, BREAK, RETURN;

/* Non terminals */
non terminal           unidade_de_compilacao;
non terminal           string;
non terminal           especificador_tipo;
non terminal           declaracao, expressao, expressao_atribuicao;
non terminal           operador_atribuicao, operador_aritmetica, constante;
non terminal           expressao_condicional, expressao_primaria;
non terminal           expressao_or, expressao_and, expressao_xor,expressao_equalidade,expressao_relacional;
non terminal           expressao_aditiva,expressao_multiplicativa;
non terminal           instrucao, instrucao_if, instrucao_iterativa, instrucao_pulo, instrucao_composta;
non terminal           comando, comando_print, comando_scan;

/* Precedences */
precedence left XOR;
precedence left AND, ADDITION, SUBTRACTION;
precedence left OR, MULTIPLICATION, DIVISION;
precedence nonassoc NOT, LESS_THAN, GREATER_THAN, EQEQ;

/* Regras */

unidade_de_compilacao ::= instrucao_composta unidade_de_compilacao
                        | 
                        ;

especificador_tipo ::= INTEGER_KEYWORD
                       | FLOAT_KEYWORD
                       | CHARACTER_KEYWORD
                       | BOOLEAN_KEYWORD
                       ;

declaracao ::= especificador_tipo IDENTIFIER 
    	       | especificador_tipo IDENTIFIER SQUARE_BRACKET_OPEN INTEGER SQUARE_BRACKET_CLOSE
               ;

expressao ::= expressao_atribuicao 
		      | expressao COMMA expressao_atribuicao 
              ;

expressao_atribuicao ::= expressao_condicional 
                         | IDENTIFIER operador_atribuicao expressao_atribuicao
                         ;

operador_atribuicao ::= EQ
                      | operador_aritmetica EQ 
                      ;

constante ::= CHAR 
              | INTEGER 
              | FLOAT 
              | BOOLEAN
              ;
                
expressao_condicional ::= expressao_or ;

expressao_or ::= expressao_and
				 | expressao_or OR expressao_and
                 ;

expressao_and ::= expressao_xor
			      | expressao_and AND expressao_xor
                  ;

expressao_xor ::= expressao_equalidade
				  | expressao_xor XOR expressao_equalidade
                  ;

expressao_equalidade ::= expressao_relacional
                         | expressao_equalidade EQEQ expressao_relacional
                         | expressao_equalidade NOT EQ expressao_relacional
                         ;

expressao_relacional ::= expressao_aditiva
                         | expressao_relacional LESS_THAN expressao_aditiva
                         | expressao_relacional GREATER_THAN expressao_aditiva
                         | expressao_relacional LESS_THAN EQ expressao_aditiva
                         | expressao_relacional GREATER_THAN EQ expressao_aditiva
                         ;

expressao_aditiva ::= expressao_multiplicativa
                      | expressao_aditiva ADDITION expressao_multiplicativa
                      | expressao_aditiva SUBTRACTION expressao_multiplicativa
                      ;

expressao_multiplicativa ::= expressao_primaria
                             | expressao_multiplicativa MULTIPLICATION expressao_primaria
                             | expressao_multiplicativa DIVISION expressao_primaria
                             ;

expressao_primaria ::= IDENTIFIER
                       | constante
                       ;
/*adaptado de "instrucao_composta ::= declaracao* instrucao*" verificar equivalencia dps */
instrucao_composta ::= declaracao instrucao_composta  
                     | instrucao instrucao_composta  
                     ;

instrucao ::= instrucao_if
              | instrucao_iterativa
              | instrucao_pulo
		      | comando
              ;

operador_aritmetica ::= ADDITION 
                      | SUBTRACTION 
                      | MULTIPLICATION
                      | DIVISION 
                      ;

instrucao_if ::= IF PARENTHESES_OPEN expressao_condicional PARENTHESES_CLOSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE
               | IF PARENTHESES_OPEN expressao_condicional PARENTHESES_CLOSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE ELSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE;

/*aqui o for aparece 4x porque o expressao condicional e expressao sao opcionais*/
instrucao_iterativa ::= WHILE PARENTHESES_OPEN expressao_condicional PARENTHESES_CLOSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON expressao_condicional SEMICOLON expressao PARENTHESES_CLOSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON expressao_condicional SEMICOLON PARENTHESES_CLOSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON  SEMICOLON expressao PARENTHESES_CLOSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON  SEMICOLON PARENTHESES_CLOSE CURLY_BRACKET_OPEN instrucao_composta CURLY_BRACKET_CLOSE
                        ;

comando ::= comando_print | comando_scan ;

comando_print ::= PRINT PARENTHESES_OPEN CURLY_BRACKET_OPEN IDENTIFIER CURLY_BRACKET_CLOSE PARENTHESES_CLOSE SEMICOLON
			      | PRINT PARENTHESES_OPEN string PARENTHESES_CLOSE SEMICOLON
                  ;

string ::= CHAR string ;

comando_scan ::= SCAN PARENTHESES_OPEN IDENTIFIER PARENTHESES_CLOSE SEMICOLON ;

instrucao_pulo ::= CONTINUE SEMICOLON
                   | BREAK SEMICOLON
                   | RETURN expressao SEMICOLON
                   ;

