/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
import java_cup.runtime.*;

parser code {:
    public void syntax_error(java_cup.runtime.Symbol currToken) {
        System.out.println("Erro de sintaxe na linha: "+(currToken.left+1)+" coluna: " +(currToken.right+1));
    }
:}

/* terminais. */
terminal            COMMA, SEMICOLON, SQUARE_BRACKET_OPEN, SQUARE_BRACKET_CLOSE, PARENTHESES_OPEN, PARENTHESES_CLOSE, CURLY_BRACKET_OPEN, CURLY_BRACKET_CLOSE;
terminal            ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, GREATER_THAN, LESS_THAN;
terminal            EQ, EQEQ, AND, OR, XOR, NOT;
terminal            INTEGER_KEYWORD, BOOLEAN_KEYWORD, CHARACTER_KEYWORD, FLOAT_KEYWORD;
terminal            IF, ELSE, WHILE, FOR, PRINT, SCAN;
terminal            FLOAT, BOOLEAN, INTEGER, CHAR, STRING;//string Ã© apenas usado no print
terminal            IDENTIFIER;
terminal            CONTINUE, BREAK, RETURN;

/* Non terminals */
non terminal           unidade_de_compilacao;
non terminal           especificador_tipo;
non terminal           declaracao, expressao, expressao_atribuicao;
non terminal           operador_atribuicao, constante;
non terminal           expressao_condicional, expressao_primaria;
non terminal           expressao_or, expressao_and, expressao_xor,expressao_equalidade,expressao_relacional;
non terminal           expressao_aditiva,expressao_multiplicativa;
non terminal           instrucao, bloco_instrucao, instrucao_if, instrucao_iterativa, instrucao_pulo, instrucao_composta;
non terminal           comando, comando_print, comando_scan;

/* Precedences */
precedence left XOR;
precedence left AND, ADDITION, SUBTRACTION;
precedence left OR, MULTIPLICATION, DIVISION;
precedence nonassoc NOT, LESS_THAN, GREATER_THAN, EQEQ;

/* Regras */

unidade_de_compilacao ::= declaracao unidade_de_compilacao
                        | instrucao unidade_de_compilacao
                        | instrucao_composta unidade_de_compilacao
                        |
                        ;

especificador_tipo ::= INTEGER_KEYWORD
                       | FLOAT_KEYWORD
                       | CHARACTER_KEYWORD
                       | BOOLEAN_KEYWORD
                       ;

declaracao ::= especificador_tipo IDENTIFIER SEMICOLON {: System.out.println("Variavel declarada\n"); :}
    	       | especificador_tipo IDENTIFIER SQUARE_BRACKET_OPEN INTEGER SQUARE_BRACKET_CLOSE SEMICOLON {: System.out.println("Variavel declarada\n"); :}
               ;

expressao ::= expressao_atribuicao 
		      | expressao COMMA expressao_atribuicao 
              ;

expressao_atribuicao ::= expressao_condicional SEMICOLON
                         | IDENTIFIER operador_atribuicao expressao_atribuicao {: System.out.println("Atribuicao feita a um identificador\n "); :}
                         ;

operador_atribuicao ::= EQ
                      ;

constante ::= CHAR 
              | INTEGER 
              | FLOAT 
              | BOOLEAN
              ;
                
expressao_condicional ::= expressao_or ;

expressao_or ::= expressao_and
				 | expressao_or OR expressao_and {: System.out.println("Expressao logica OR encontrada \n "); :}
                 ;

expressao_and ::= expressao_xor
			      | expressao_and AND expressao_xor {: System.out.println("Expressao logica AND encontrada \n "); :}
                  ;

expressao_xor ::= expressao_equalidade
				  | expressao_xor XOR expressao_equalidade {: System.out.println("Expressao logica XOR encontrada \n "); :}
                  ;

expressao_equalidade ::= expressao_relacional
                         | expressao_equalidade EQEQ expressao_relacional  {: System.out.println("Expressao relacional '==' encontrada \n "); :}
                         | expressao_equalidade NOT EQ expressao_relacional {: System.out.println("Expressao relacional '!=' encontrada \n "); :}
                         ;

expressao_relacional ::= expressao_aditiva
                         | expressao_relacional LESS_THAN expressao_aditiva {: System.out.println("Expressao relacional '<' encontrada \n "); :}
                         | expressao_relacional GREATER_THAN expressao_aditiva {: System.out.println("Expressao relacional '>' encontrada \n "); :}
                         | expressao_relacional LESS_THAN EQ expressao_aditiva  {: System.out.println("Expressao relacional '<=' encontrada \n "); :}
                         | expressao_relacional GREATER_THAN EQ expressao_aditiva {: System.out.println("Expressao relacional '>=' encontrada \n "); :}
                         ;

expressao_aditiva ::= expressao_multiplicativa
                      | expressao_aditiva ADDITION expressao_multiplicativa {: System.out.println("Expressao aritmetica de ADICAO encontrada \n "); :}
                      | expressao_aditiva SUBTRACTION expressao_multiplicativa {: System.out.println("Expressao aritmetica de SUBTRACAO encontrada \n "); :}
                      ;

expressao_multiplicativa ::= expressao_primaria
                             | expressao_multiplicativa MULTIPLICATION expressao_primaria {: System.out.println("Expressao aritmetica de MULTIPLICACAO encontrada \n "); :}
                             | expressao_multiplicativa DIVISION expressao_primaria {: System.out.println("Expressao aritmetica de  DIVISAO encontrada \n "); :}
                             ;

expressao_primaria ::= IDENTIFIER

                       | constante
                       ;
/*adaptado de "instrucao_composta ::= { declaracao* instrucao* }" verificar equivalencia dps */
instrucao_composta ::= CURLY_BRACKET_OPEN bloco_instrucao CURLY_BRACKET_CLOSE
                     ;

bloco_instrucao ::= /* empty */
                  | declaracao bloco_instrucao
                  | instrucao bloco_instrucao
                  ;

instrucao ::= expressao
              | instrucao_if
              | instrucao_iterativa
              | instrucao_pulo
		      | comando
              ;

instrucao_if ::= IF PARENTHESES_OPEN expressao_condicional PARENTHESES_CLOSE instrucao_composta {: System.out.println("Fim da Instrucao IF\n "); :}
               | IF PARENTHESES_OPEN expressao_condicional PARENTHESES_CLOSE instrucao_composta ELSE instrucao_composta {: System.out.println("Fim da Instrucao IF ELSE\n "); :}
               ;

/*aqui o for aparece 4x porque o expressao condicional e expressao sao opcionais*/
instrucao_iterativa ::= WHILE PARENTHESES_OPEN expressao_condicional PARENTHESES_CLOSE instrucao_composta {: System.out.println("Fim do Comando WHILE\n "); :}
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON expressao_condicional SEMICOLON expressao PARENTHESES_CLOSE instrucao_composta {: System.out.println("Fim do Comando FOR\n "); :}
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON expressao_condicional SEMICOLON PARENTHESES_CLOSE instrucao_composta {: System.out.println("Fim do Comando FOR\n "); :}
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON SEMICOLON expressao PARENTHESES_CLOSE instrucao_composta {: System.out.println("Fim do Comando FOR\n "); :}
                        | FOR PARENTHESES_OPEN expressao_atribuicao SEMICOLON SEMICOLON PARENTHESES_CLOSE instrucao_composta {: System.out.println("Fim do Comando FOR \n "); :}
                        ;
                        
instrucao_pulo ::= CONTINUE SEMICOLON
                   | BREAK SEMICOLON
                   | RETURN expressao SEMICOLON
                   ;

comando ::= comando_print | comando_scan ;

comando_print ::= PRINT PARENTHESES_OPEN IDENTIFIER PARENTHESES_CLOSE SEMICOLON{: System.out.println("Comando PRINT encontrado\n "); :}
			      | PRINT PARENTHESES_OPEN STRING PARENTHESES_CLOSE SEMICOLON{: System.out.println("Comando PRINT encontrado\n "); :}
                  ;

comando_scan ::= SCAN PARENTHESES_OPEN IDENTIFIER PARENTHESES_CLOSE SEMICOLON {: System.out.println("Comando SCAN encontrado\n "); :};



